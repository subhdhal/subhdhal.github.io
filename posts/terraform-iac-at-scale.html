<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infrastructure as Code at Scale: Terraform Patterns for Multi-Account AWS - Subhashree Dhal</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
</head>
<body>
    <div class="container">
        <!-- Navigation -->
        <nav class="nav">
            <ul class="nav-list">
                <li><a href="../index.html">home</a></li>
                <li><a href="../about.html">about</a></li>
                <li><a href="../posts.html" class="active">posts</a></li>
                <li><a href="../resume.html">resume</a></li>
            </ul>
            <div class="theme-toggle">
                <button id="theme-btn" class="theme-btn" aria-label="Toggle dark mode">
                    <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="content">
            <article>
                <h1>Infrastructure as Code at Scale: Terraform Patterns for Multi-Account AWS</h1>
                <p class="post-date">December 2024</p>
                
                <section>
                    <h2>Introduction</h2>
                    <p>
                        Managing infrastructure across 50+ AWS accounts with 100+ engineers requires more than just writing Terraform code. 
                        It requires patterns, standards, and governance that prevent chaos while maintaining team velocity. In this post, 
                        I'll share the Terraform architecture that helped us reduce provisioning time by 80% while maintaining security 
                        and compliance across all accounts.
                    </p>
                </section>

                <section>
                    <h2>The Challenge: Scaling Terraform Beyond a Single Account</h2>
                    <p>
                        When you're managing infrastructure at scale, several problems emerge:
                    </p>
                    <ul>
                        <li><strong>Code Duplication:</strong> Repeating the same resources across accounts creates maintenance burden</li>
                        <li><strong>State Management:</strong> Large monolithic state files become slow and fragile</li>
                        <li><strong>Consistency:</strong> Different teams creating resources with different standards</li>
                        <li><strong>Permissions:</strong> Engineers shouldn't have access to production accounts</li>
                        <li><strong>Drift Detection:</strong> Manual changes accumulate over time</li>
                        <li><strong>Cost Visibility:</strong> Difficult to track which team created which resources</li>
                    </ul>
                </section>

                <section>
                    <h2>Architecture: Monorepo with Modular Terraform</h2>
                    <p>
                        We chose a monorepo structure with clear separation of concerns:
                    </p>
                    <pre><code>infrastructure/
├── terraform/
│   ├── modules/                    # Reusable components
│   │   ├── networking/
│   │   │   ├── vpc/
│   │   │   ├── security-groups/
│   │   │   └── nat-gateway/
│   │   ├── compute/
│   │   │   ├── eks-cluster/
│   │   │   ├── ec2-fleet/
│   │   │   └── auto-scaling/
│   │   ├── data/
│   │   │   ├── rds-postgres/
│   │   │   ├── dynamodb-table/
│   │   │   └── s3-bucket/
│   │   ├── security/
│   │   │   ├── iam-roles/
│   │   │   ├── kms-key/
│   │   │   └── security-groups/
│   │   └── observability/
│   │       ├── cloudwatch-dashboards/
│   │       ├── log-groups/
│   │       └── sns-topics/
│   │
│   ├── environments/                # Environment-specific configs
│   │   ├── dev/
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── terraform.tfvars
│   │   ├── staging/
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── terraform.tfvars
│   │   └── production/
│   │       ├── main.tf
│   │       ├── variables.tf
│   │       └── terraform.tfvars
│   │
│   ├── accounts/                   # Multi-account setup
│   │   ├── core/
│   │   │   ├── organization.tf
│   │   │   ├── networking.tf
│   │   │   └── security-controls.tf
│   │   ├── dev-account/
│   │   ├── staging-account/
│   │   └── prod-account/
│   │
│   ├── shared/                     # Shared resources
│   │   ├── state-backend/
│   │   ├── terraform-cloud-config/
│   │   └── ci-cd-roles/
│   │
│   └── global/
│       ├── variables.tf
│       ├── providers.tf
│       ├── backend.tf
│       └── locals.tf</code></pre>
                </section>

                <section>
                    <h2>Pattern 1: Modular Reusable Components</h2>
                    <p>
                        Each module is self-contained and reusable:
                    </p>
                    <pre><code># modules/compute/eks-cluster/main.tf

variable "cluster_name" {
  type        = string
  description = "EKS cluster name"
}

variable "version" {
  type        = string
  description = "Kubernetes version"
  default     = "1.27"
}

variable "node_groups" {
  type = map(object({
    desired_size    = number
    min_size        = number
    max_size        = number
    instance_types  = list(string)
    disk_size       = number
    labels          = map(string)
    taints          = list(object({
      key    = string
      value  = string
      effect = string
    }))
  }))
  description = "Node group configurations"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID for cluster"
}

variable "subnet_ids" {
  type        = list(string)
  description = "Subnet IDs for cluster"
}

variable "enable_monitoring" {
  type        = bool
  default     = true
  description = "Enable CloudWatch Container Insights"
}

resource "aws_eks_cluster" "main" {
  name     = var.cluster_name
  version  = var.version
  role_arn = aws_iam_role.cluster.arn

  vpc_config {
    subnet_ids              = var.subnet_ids
    endpoint_private_access = true
    endpoint_public_access  = true
    public_access_cidrs     = ["0.0.0.0/0"]
  }

  # Encryption for secrets at rest
  encryption_config {
    provider {
      key_arn = aws_kms_key.eks.arn
    }
    resources = ["secrets"]
  }

  enabled_cluster_log_types = [
    "api",
    "audit",
    "authenticator",
    "controllerManager",
    "scheduler"
  ]

  tags = merge(
    var.common_tags,
    { Name = var.cluster_name }
  )
}

# Output for other modules to reference
output "cluster_id" {
  value       = aws_eks_cluster.main.id
  description = "EKS cluster ID"
}

output "cluster_endpoint" {
  value       = aws_eks_cluster.main.endpoint
  description = "EKS cluster API endpoint"
}

output "cluster_security_group_id" {
  value       = aws_eks_cluster.main.vpc_config[0].cluster_security_group_id
  description = "Security group associated with cluster"
}</code></pre>

                    <p>
                        <strong>Key Design Principles:</strong>
                    </p>
                    <ul>
                        <li>High input flexibility via variables for customization</li>
                        <li>Sensible defaults for most environments</li>
                        <li>Clear outputs for inter-module dependencies</li>
                        <li>Built-in security (encryption, logging, IAM)</li>
                        <li>Comprehensive tagging strategy</li>
                    </ul>
                </section>

                <section>
                    <h2>Pattern 2: Environment-Specific Configurations</h2>
                    <p>
                        Use the same module code but different variables per environment:
                    </p>
                    <pre><code># environments/dev/main.tf

locals {
  environment = "dev"
  region      = "us-east-1"
  
  common_tags = {
    Environment = local.environment
    ManagedBy   = "Terraform"
    CostCenter  = "Engineering"
  }
}

provider "aws" {
  region = local.region
  
  default_tags {
    tags = local.common_tags
  }
}

# Use modules for consistent structure
module "networking" {
  source = "../../modules/networking/vpc"
  
  vpc_cidr       = "10.0.0.0/16"
  environment    = local.environment
  availability_zones = ["us-east-1a", "us-east-1b"]
  
  tags = local.common_tags
}

module "eks_cluster" {
  source = "../../modules/compute/eks-cluster"
  
  cluster_name = "${local.environment}-cluster"
  version      = "1.27"
  vpc_id       = module.networking.vpc_id
  subnet_ids   = module.networking.private_subnet_ids
  
  node_groups = {
    general = {
      desired_size   = 3
      min_size       = 1
      max_size       = 10
      instance_types = ["t3.large"]
      disk_size      = 50
      labels = {
        workload-type = "general"
      }
    }
    compute = {
      desired_size   = 2
      min_size       = 0
      max_size       = 20
      instance_types = ["c5.xlarge"]
      disk_size      = 100
      labels = {
        workload-type = "compute"
      }
      taints = [{
        key    = "compute"
        value  = "true"
        effect = "NoSchedule"
      }]
    }
  }
  
  enable_monitoring = true
  tags              = local.common_tags
}

# environments/dev/terraform.tfvars
# Dev environment: minimal resources for cost savings
instance_type     = "t3.medium"
min_replicas      = 1
max_replicas      = 5
backup_retention  = 7
enable_ha         = false</code></pre>

                    <p>
                        Now the production environment uses the exact same code:
                    </p>
                    <pre><code># environments/production/terraform.tfvars
# Production environment: high availability, enhanced monitoring
instance_type     = "c5.xlarge"
min_replicas      = 3
max_replicas      = 100
backup_retention  = 30
enable_ha         = true
enable_monitoring = true
enable_logging    = true</code></pre>

                    <p>
                        This ensures production and dev use identical module logic but different configurations.
                    </p>
                </section>

                <section>
                    <h2>Pattern 3: Multi-Account Architecture with Assume Roles</h2>
                    <p>
                        Manage all accounts from a central CI/CD pipeline using cross-account IAM roles:
                    </p>
                    <pre><code># accounts/core/main.tf - Setup organization structure

# Create member accounts
resource "aws_organizations_account" "dev_account" {
  name              = "dev"
  email             = "dev-account@example.com"
  parent_id         = aws_organizations_organizational_unit.engineering.id
  close_on_deletion = false
}

resource "aws_organizations_account" "prod_account" {
  name              = "production"
  email             = "prod-account@example.com"
  parent_id         = aws_organizations_organizational_unit.production.id
  close_on_deletion = false
}

# Create IAM role in dev account that can be assumed from core account
resource "aws_iam_role" "terraform_role_dev" {
  provider = aws.dev
  name     = "terraform-runner"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Principal = {
        AWS = "arn:aws:iam::${local.core_account_id}:root"
      }
      Action = "sts:AssumeRole"
      Condition = {
        StringEquals = {
          "sts:ExternalId" = var.terraform_external_id
        }
      }
    }]
  })
}

resource "aws_iam_role_policy_attachment" "terraform_policy_dev" {
  provider       = aws.dev
  role           = aws_iam_role.terraform_role_dev.name
  policy_arn     = "arn:aws:iam::aws:policy/PowerUserAccess"
}

# CI/CD assumes this role to deploy infrastructure
# terraform/accounts/dev/main.tf

provider "aws" {
  alias = "dev"
  
  assume_role {
    role_arn    = "arn:aws:iam::${var.dev_account_id}:role/terraform-runner"
    external_id = var.terraform_external_id
  }
  
  default_tags {
    tags = local.common_tags
  }
}</code></pre>
                </section>

                <section>
                    <h2>Pattern 4: State Management at Scale</h2>
                    <p>
                        Split monolithic state files into smaller, focused states:
                    </p>
                    <pre><code># Global strategy: Split by environment AND by concern

infrastructure/
├── terraform/
│   ├── environments/
│   │   ├── dev/
│   │   │   ├── networking/          # State for VPC, subnets, NAT
│   │   │   │   └── backend.tf
│   │   │   ├── compute/             # State for EC2, EKS, ASG
│   │   │   │   └── backend.tf
│   │   │   ├── databases/           # State for RDS, DynamoDB
│   │   │   │   └── backend.tf
│   │   │   └── security/            # State for IAM, KMS, Secrets
│   │   │       └── backend.tf
│   │   ├── staging/
│   │   └── production/

# terraform/environments/dev/networking/backend.tf

terraform {
  backend "s3" {
    bucket         = "org-terraform-state"
    key            = "dev/networking/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks"
    encrypt        = true
  }
}

# Each workspace keeps state independent
# This prevents giant state files that take minutes to plan</code></pre>

                    <p>
                        <strong>Benefits of splitting state:</strong>
                    </p>
                    <ul>
                        <li>Faster plan and apply (smaller state = faster processing)</li>
                        <li>Better isolation (networking changes won't lock database state)</li>
                        <li>Team ownership (team-a owns compute, team-b owns databases)</li>
                        <li>Reduced blast radius (mistake in networking doesn't affect databases)</li>
                    </ul>
                </section>

                <section>
                    <h2>Pattern 5: Tagging Strategy for Cost & Governance</h2>
                    <p>
                        Comprehensive tagging enables cost allocation and compliance:
                    </p>
                    <pre><code># terraform/global/locals.tf

locals {
  # Standard tags applied to all resources
  common_tags = {
    # Organizational tags
    Organization = "MyCompany"
    Environment  = var.environment
    Team         = var.team
    
    # Cost allocation tags
    CostCenter      = var.cost_center
    BillingCode     = var.billing_code
    ProjectName     = var.project_name
    
    # Compliance & governance tags
    Compliance      = var.compliance_requirement  # "SOC2", "HIPAA", "PCI-DSS"
    DataClassification = var.data_classification # "public", "internal", "confidential"
    BackupPolicy    = var.backup_policy          # "daily", "weekly", "monthly"
    
    # Operational tags
    ManagedBy       = "Terraform"
    CreatedDate     = timestamp()
    CreatedBy       = var.created_by
    
    # Automation tags
    AutoShutdown    = var.auto_shutdown          # "true" for dev
    ScheduleTag     = var.schedule_tag           # "business-hours", "always-on"
  }
}

# Usage in resource definitions
resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
  
  tags = merge(
    local.common_tags,
    {
      Name = "web-server-1"
      Role = "web"
    }
  )
}

# This enables:
# 1. Cost allocation by team, project, cost-center
# 2. Compliance audits (which resources need HIPAA?)
# 3. Automated actions (auto-shutdown non-production resources)
# 4. Asset tracking (what was created, by whom, when)</code></pre>
                </section>

                <section>
                    <h2>Pattern 6: Drift Detection and Remediation</h2>
                    <p>
                        Automatically detect and alert on configuration drift:
                    </p>
                    <pre><code># CI/CD Pipeline: Daily drift detection

stages:
  drift-detection:
    schedule: '0 2 * * *'  # Run at 2 AM daily
    script:
      - terraform init
      - terraform plan -json > plan.json
      
      # Check if plan shows any changes
      - |
        if grep -q '"type":"change"' plan.json; then
          echo "Configuration drift detected!"
          # Send alert to Slack
          curl -X POST $SLACK_WEBHOOK_URL \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "⚠️ Terraform drift detected in production",
              "attachments": [{
                "color": "warning",
                "text": "Manual changes detected. Review and reconcile."
              }]
            }'
          
          # Create GitHub issue
          gh issue create \
            --title "Configuration drift detected: $(date)" \
            --body "$(cat plan.json)"
          
          exit 1  # Fail if drift found
        fi

# Remediate drift automatically (with safeguards)
auto-remediate:
  when: on_failure
  script:
    - |
      if [ "$ALLOW_AUTO_REMEDIATE" == "true" ]; then
        echo "Reverting manual changes..."
        terraform apply -auto-approve
      fi</code></pre>
                </section>

                <section>
                    <h2>Pattern 7: Version Control and Terraform Module Versioning</h2>
                    <p>
                        Manage module versions similar to software packages:
                    </p>
                    <pre><code># Reference modules by Git tag/version

# terraform/environments/dev/main.tf

module "eks_cluster" {
  source = "git::https://github.com/org/terraform-modules.git//compute/eks-cluster?ref=v1.2.3"
  
  cluster_name = "dev-cluster"
  # ... variables
}

# This allows:
# 1. Testing module changes before rolling out
# 2. Different environments using different module versions
# 3. Easy rollback if module has issues

# When a new module version is released:
# 1. Test in dev (ref=v1.3.0)
# 2. Verify compatibility
# 3. Update staging (ref=v1.3.0)
# 4. Finally update production (ref=v1.3.0)</code></pre>
                </section>

                <section>
                    <h2>CI/CD Integration: GitOps for Infrastructure</h2>
                    <p>
                        Integrate Terraform with CI/CD for safe deployments:
                    </p>
                    <pre><code># .gitlab-ci.yml

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/terraform
  PLAN_JSON: ${TF_ROOT}/plan.json
  PLAN_PRETTY: ${TF_ROOT}/plan.txt

stages:
  - validate
  - plan
  - apply

validate:
  stage: validate
  script:
    - cd $TF_ROOT
    - terraform init -backend=false
    - terraform validate
    - terraform fmt -check -recursive

plan:
  stage: plan
  script:
    - cd $TF_ROOT
    - terraform init
    - terraform plan -json | tee $PLAN_JSON
    
    # Generate human-readable plan
    - terraform show -no-color $PLAN_JSON > $PLAN_PRETTY
    
    # Post plan to MR for review
    - |
      if [ "$CI_MERGE_REQUEST_IID" ]; then
        curl -X POST \
          --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
          https://gitlab.example.com/api/v4/projects/$CI_PROJECT_ID/merge_requests/$CI_MERGE_REQUEST_IID/notes \
          -d "body=$(cat $PLAN_PRETTY)"
      fi
  artifacts:
    paths:
      - $PLAN_JSON
      - $PLAN_PRETTY

apply:
  stage: apply
  script:
    - cd $TF_ROOT
    - terraform init
    - terraform apply -json -input=false $PLAN_JSON
  when: manual  # Require manual approval before applying
  only:
    - main

# Key benefits:
# 1. All infrastructure changes require code review
# 2. Plan shown in merge request before approval
# 3. Audit trail in Git history
# 4. Easy rollback via Git revert</code></pre>
                </section>

                <section>
                    <h2>Results: 80% Faster Provisioning, 99.2% Compliance</h2>
                    <ul>
                        <li><strong>Before:</strong>
                            <ul>
                                <li>Manual provisioning: 2-4 weeks</li>
                                <li>Compliance verification: 1-2 weeks</li>
                                <li>Total time to production: 3-6 weeks</li>
                                <li>Compliance score: 72%</li>
                            </ul>
                        </li>
                        <li><strong>After:</strong>
                            <ul>
                                <li>Terraform provisioning: 5-10 minutes</li>
                                <li>Code review: 30 minutes to 2 hours</li>
                                <li>Total time to production: 3-4 hours</li>
                                <li>Compliance score: 99.2%</li>
                                <li>Infrastructure drift: 0 (detected and fixed automatically)</li>
                            </ul>
                        </li>
                    </ul>
                </section>

                <section>
                    <h2>Lessons Learned</h2>
                    <ul>
                        <li><strong>Modules over monoliths:</strong> Small, focused modules are more reusable and maintainable</li>
                        <li><strong>Split state early:</strong> Don't wait until your state files become unwieldy</li>
                        <li><strong>Security by default:</strong> Encryption, logging, and IAM should be in module defaults</li>
                        <li><strong>Code review infrastructure:</strong> Every infrastructure change requires the same scrutiny as code</li>
                        <li><strong>Document assumptions:</strong> Modules should clearly document required inputs and expected outputs</li>
                        <li><strong>Test modules:</strong> Use Terratest or similar to validate module behavior before release</li>
                        <li><strong>Plan before apply:</strong> Always review plans and store them for audit trail</li>
                    </ul>
                </section>

                <section>
                    <h2>Conclusion</h2>
                    <p>
                        Terraform at scale requires more than just knowing HCL syntax. It requires thoughtful architecture, clear patterns, 
                        and strong governance. By adopting modular design, splitting state, standardizing tagging, and integrating with CI/CD, 
                        we transformed infrastructure provisioning from a 3-6 week manual process to a 3-4 hour automated one.
                    </p>
                    <p>
                        The key insight: <strong>Infrastructure as Code is not about writing code—it's about building systems that are 
                        secure, auditable, and scalable from day one.</strong>
                    </p>
                </section>

                <div style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
                    <p><a href="../posts.html">← Back to all posts</a></p>
                </div>
            </article>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <p>&copy; 2025 Subhashree Dhal. All rights reserved.</p>
        </footer>
    </div>

    <script src="../js/main.js"></script>
</body>
</html>
